<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>–§—É—Ç–±–æ–ª—å–Ω–∞—è –∏–≥—Ä–∞</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        :root {
            --bg-color: #1a1a1a; --primary-color: #2c2c2c; --secondary-color: #444;
            --empty-column-color: #222;
            --text-color: #f0f0f0; --accent-color: #0088cc; --accent-hover-color: #00aaff;
            --correct-color: #28a745; --incorrect-color: #dc3545; --cancel-color: #aa4a44;
            --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        }
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; font-family: var(--font-family); background-color: var(--bg-color); color: var(--text-color); overflow: hidden; }
        .screen { display: none; width: 100%; height: 100%; overflow-y: auto; box-sizing: border-box; padding: 15px; }
        .screen.active { display: flex; flex-direction: column; align-items: center; }
        button { background-color: var(--accent-color); color: white; border: none; padding: 12px 20px; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold; transition: background-color 0.2s; -webkit-tap-highlight-color: transparent; }
        button:hover { background-color: var(--accent-hover-color); }
        button:disabled { background-color: var(--secondary-color); cursor: not-allowed; }
        input[type="text"], input[type="number"], select { width: 100%; padding: 12px; margin-bottom: 10px; border-radius: 8px; border: 1px solid var(--secondary-color); background-color: var(--primary-color); color: var(--text-color); font-size: 16px; box-sizing: border-box; }
        /* –°—Ç–∏–ª—å –¥–ª—è –ø–ª–µ–π—Å—Ö–æ–ª–¥–µ—Ä–∞ –≤–æ –≤—Ä–µ–º—è —á—É–∂–æ–≥–æ —Ö–æ–¥–∞ */
        input[type="text"].opponent-turn::placeholder {
             color: #aaa;
             font-style: italic;
        }
        .container { width: 100%; max-width: 600px; margin: 0 auto; text-align: center; }
        #loading-screen { justify-content: center; }
        #loading-screen p { margin-top: 15px; }
        .loader { border: 8px solid var(--secondary-color); border-top: 8px solid var(--accent-color); border-radius: 50%; width: 60px; height: 60px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #nickname-screen .container { display: flex; flex-direction: column; justify-content: center; height: 100%; }
        #lobby-screen h1 { margin-top: 0; }
        .game-card { background-color: var(--primary-color); padding: 15px; border-radius: 8px; margin-bottom: 10px; text-align: left; display: flex; justify-content: space-between; align-items: center; }
        .game-card-info p { margin: 4px 0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .game-card-info .spectators { font-size: 12px; color: #aaa; margin-top: 5px; }
        #settings-screen .container { text-align: left; }
        #game-screen .game-header { display: flex; justify-content: space-between; align-items: center; width: 100%; margin-bottom: 15px; }
        .player-info { padding: 5px; border-radius: 4px; border-bottom: 2px solid transparent; padding-bottom: 3px; text-align: center; flex: 1; min-width: 0; }
        .player-info .nickname { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .player-info.active { border-bottom: 2px solid var(--accent-color); }
        .player-info .score { margin-top: 4px; }

        #named-players-container {
            display: flex;
            justify-content: space-between;
            margin: 15px -5px;
            max-height: 40vh;
            overflow-y: hidden;
        }
        .named-players-column {
            list-style: none;
            padding: 10px;
            margin: 0 5px;
            flex: 1;
            text-align: left;
            overflow-y: auto;
            border: 1px solid var(--secondary-color);
            border-radius: 5px;
            background-color: var(--primary-color);
            display: flex;
            flex-direction: column-reverse;
            min-height: 100px;
            transition: background-color 0.3s;
        }

        .named-players-column li { margin-top: 5px; word-break: break-word; }
        #spectator-info { margin-top: 5px; font-size: 12px; color: #aaa; height: 15px; text-align: center; }
        #spectator-back-btn { margin-top: 15px; width: 100%; background-color: var(--secondary-color); }
        .game-controls { margin-top: 10px; }

        #leaderboard-screen table, #game-over-table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        #leaderboard-screen th, #leaderboard-screen td, #game-over-table th, #game-over-table td { padding: 10px; border-bottom: 1px solid var(--secondary-color); text-align: left; }
        #game-over-table th { background-color: var(--primary-color); }

        .cancel-btn { background-color: var(--cancel-color); }
        .cancel-btn:hover { background-color: #c45a54; }

        .tabs-container { display: flex; margin-bottom: 15px; }
        .tab-btn { flex: 1; padding: 10px; background-color: var(--primary-color); border: 1px solid var(--secondary-color); color: var(--text-color); cursor: pointer; border-radius: 0; }
        .tab-btn:first-child { border-top-left-radius: 8px; border-bottom-left-radius: 8px; }
        .tab-btn:last-child { border-top-right-radius: 8px; border-bottom-right-radius: 8px; }
        .tab-btn.active { background-color: var(--accent-color); border-color: var(--accent-color); font-weight: bold; }
        .tab-content { display: none; padding: 15px; background-color: var(--primary-color); border-radius: 8px; }
        .tab-content.active { display: block; }
        #clubs-selection-list { max-height: 200px; overflow-y: auto; border: 1px solid var(--secondary-color); padding: 10px; border-radius: 8px; }
        .club-item { display: block; text-align: left; margin: 5px 0; }
        #settings-error-msg { color: var(--incorrect-color); min-height: 20px; margin-top: 10px; }

        .button-row { display: flex; gap: 10px; margin-top: 20px; }
        .button-row button { flex: 1; margin: 0; }
        .secondary-btn { background-color: var(--secondary-color); }
        .secondary-btn:hover { background-color: #555; }

        #summary-screen .container { text-align: left; }
        #summary-screen h2, #summary-screen h3, #summary-screen p { text-align: center; }
        .summary-list-wrapper { position: relative; }
        .summary-list-wrapper h4 { text-align: center; }
        #summary-list-container { position: relative; max-height: 40vh; overflow-y: auto; border: 1px solid var(--secondary-color); border-radius: 8px; padding: 10px; background-color: var(--primary-color); -webkit-overflow-scrolling: touch; }
        .summary-list-wrapper::after { content: ''; position: absolute; bottom: 1px; left: 1px; right: 1px; height: 30px; background: linear-gradient(to top, var(--primary-color) 0%, rgba(44, 44, 44, 0) 100%); pointer-events: none; border-bottom-left-radius: 8px; border-bottom-right-radius: 8px; transition: opacity 0.3s; opacity: 1; }
        .summary-list-wrapper.scrolled-to-bottom::after { opacity: 0; }
        #summary-player-list { list-style: none; padding: 0; margin: 0; text-align: left; }
        #summary-countdown { text-align: center; font-size: 20px; font-weight: bold; margin-bottom: 10px; }

        #game-over-screen .container { text-align: left; }
        #game-over-screen h2, #game-over-screen h3 { text-align: center; }
        #game-over-score { font-size: 24px; font-weight: bold; text-align: center; }
        #game-over-reason { text-align: center; font-style: italic; color: #aaa; margin-top: 5px; margin-bottom: 10px;}
        #game-over-ratings { text-align: center; margin-top: 15px; margin-bottom: 20px; line-height: 1.5; }
        #game-over-buttons { display: flex; gap: 10px; margin-top: 20px; }
        #game-over-buttons button { flex: 1; }
        .lobby-section-title { margin-top: 20px; border-bottom: 1px solid var(--secondary-color); padding-bottom: 5px; text-align: left; }
        #lobby-stats { font-size: 14px; color: #aaa; margin-bottom: 15px; text-align: center; line-height: 1.4; }

    </style>
</head>
<body>

    <div id="loading-screen" class="screen active"><div class="container"><div class="loader"></div><p>–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...</p></div></div>
    <div id="nickname-screen" class="screen"><div class="container"><h2>–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å!</h2><p>–ü—Ä–∏–¥—É–º–∞–π—Ç–µ –Ω–∏–∫–Ω–µ–π–º (3-20 —Å–∏–º–≤).</p><input type="text" id="nickname-input" placeholder="–í–≤–µ–¥–∏—Ç–µ –≤–∞—à –Ω–∏–∫–Ω–µ–π–º"><button id="submit-nickname-btn">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button><p id="nickname-error" style="color: var(--incorrect-color);"></p></div></div>
    <div id="lobby-screen" class="screen"><div class="container"><h1>–õ–æ–±–±–∏</h1><p id="welcome-message"></p><div id="lobby-stats">–ó–∞–≥—Ä—É–∑–∫–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏...</div><div class="lobby-actions" style="display: flex; justify-content: space-around; margin-bottom: 20px;"><button id="create-game-btn">–°–æ–∑–¥–∞—Ç—å –∏–≥—Ä—É</button><button id="start-training-btn">–¢—Ä–µ–Ω–∏—Ä–æ–≤–∫–∞</button><button id="show-leaderboard-btn">–†–µ–π—Ç–∏–Ω–≥</button></div>
    <h2 class="lobby-section-title">–û—Ç–∫—Ä—ã—Ç—ã–µ –∏–≥—Ä—ã:</h2><div id="open-games-list"><p>–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∏–≥—Ä.</p></div>
    <h2 class="lobby-section-title">–¢–µ–∫—É—â–∏–µ –∏–≥—Ä—ã:</h2><div id="active-games-list"><p>–ù–µ—Ç —Ç–µ–∫—É—â–∏—Ö –∏–≥—Ä.</p></div>
    </div></div>

    <div id="settings-screen" class="screen">
        <div class="container">
            <h2 id="settings-title">–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ò–≥—Ä—ã</h2>
            <div class="setting"> <label for="league-select">–õ–∏–≥–∞:</label> <select id="league-select"><option value="–†–ü–õ">–†–ü–õ</option></select> </div>
            <div class="setting"> <label for="time-bank-input">–í—Ä–µ–º—è (—Å–µ–∫—É–Ω–¥):</label> <input type="number" id="time-bank-input" value="90" min="30" max="300"> </div>
            <div class="tabs-container"> <button class="tab-btn active" data-tab="random">–°–ª—É—á–∞–π–Ω—ã–µ –∫–ª—É–±—ã</button> <button class="tab-btn" data-tab="manual">–í—ã–±—Ä–∞—Ç—å</button> </div>
            <div id="tab-random" class="tab-content active"> <label for="random-clubs-slider" id="random-clubs-label">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–ª—É–±–æ–≤: 10</label> <p style="font-size: 12px; color: #aaa;">–ò–≥—Ä–∞ –≤—ã–±–µ—Ä–µ—Ç —Å–ª—É—á–∞–π–Ω—ã–µ –∫–ª—É–±—ã.</p> <input type="range" id="random-clubs-slider" min="1" max="16" value="10" style="width: 100%;"> </div>
            <div id="tab-manual" class="tab-content"> <p style="font-size: 12px; color: #aaa;">–í—ã–±–µ—Ä–∏—Ç–µ –æ—Ç <span id="min-clubs-text">3</span> –¥–æ <span id="max-clubs-count">16</span> –∫–ª—É–±–æ–≤.</p> <p id="manual-clubs-count" style="font-weight: bold;">–í—ã–±—Ä–∞–Ω–æ: 0</p> <div id="clubs-selection-list"></div> </div>
            <p id="settings-error-msg"></p>
            <div class="button-row"> <button id="back-to-lobby-btn" class="secondary-btn">–ù–∞–∑–∞–¥</button> <button id="confirm-create-game-btn" disabled>–°–æ–∑–¥–∞—Ç—å PvP</button> <button id="confirm-training-btn" style="display: none;" disabled>–ù–∞—á–∞—Ç—å</button> </div>
        </div>
    </div>

    <div id="game-screen" class="screen">
        <div class="container">
            <div class="game-header">
                <div class="player-info" id="player-0-info"><div class="nickname">...</div><div class="time-bank">...</div><div class="score">...</div></div>
                <div id="round-info">...</div>
                <div class="player-info" id="player-1-info"><div class="nickname">...</div><div class="time-bank">...</div><div class="score">...</div></div>
            </div>
            <h2 id="club-name-display">–ö–ª—É–±...</h2>
            <div id="spectator-info"></div>
            <div id="named-players-container">
                <ul class="named-players-column" id="named-players-list-0"></ul>
                <ul class="named-players-column" id="named-players-list-1"></ul>
            </div>
            <p id="guess-result-msg" style="height: 20px;"></p>
            <div id="game-controls">
                <input type="text" id="guess-input" placeholder="–í–≤–µ–¥–∏—Ç–µ —Ñ–∞–º–∏–ª–∏—é –∏–≥—Ä–æ–∫–∞">
                <button id="submit-guess-btn">–û—Ç–≤–µ—Ç–∏—Ç—å</button>
                <button id="surrender-btn" style="background-color: var(--cancel-color);">–°–¥–∞—Ç—å—Å—è</button>
            </div>
            <button id="spectator-back-btn" style="display: none;">–ù–∞–∑–∞–¥ –≤ –ª–æ–±–±–∏</button>
        </div>
    </div>

    <div id="summary-screen" class="screen">
        <div class="container">
            <h2 id="summary-title">–†–∞—É–Ω–¥ –∑–∞–≤–µ—Ä—à–µ–Ω!</h2>
            <h3 id="summary-club-name"></h3>
            <p><strong>–¢–µ–∫—É—â–∏–π —Å—á–µ—Ç: <span id="summary-score">0 - 0</span></strong></p>
            <div class="summary-list-wrapper">
                <h4>–í–µ—Å—å —Å–æ—Å—Ç–∞–≤:</h4>
                <div id="summary-list-container"> <ul id="summary-player-list"></ul> </div>
            </div>
            <p id="summary-countdown">10</p>
            <button id="skip-pause-btn" style="width: 100%; margin-top: 10px;">–°–ª–µ–¥—É—é—â–∏–π —Ä–∞—É–Ω–¥</button>
        </div>
    </div>

    <div id="leaderboard-screen" class="screen">
        <div class="container">
            <h2>–¢–∞–±–ª–∏—Ü–∞ –ª–∏–¥–µ—Ä–æ–≤</h2>
            <table id="leaderboard-table"><thead><tr><th>#</th><th>–ù–∏–∫–Ω–µ–π–º</th><th>–†–µ–π—Ç–∏–Ω–≥</th><th>–ò–≥—Ä</th></tr></thead><tbody></tbody></table>
            <button id="leaderboard-back-btn">–ù–∞–∑–∞–¥</button>
        </div>
    </div>

    <div id="game-over-screen" class="screen">
        <div class="container">
            <h2>–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞!</h2>
            <p id="game-over-score">–°—á–µ—Ç 0 - 0</p>
            <p id="game-over-reason">–ü—Ä–∏—á–∏–Ω–∞...</p>
            <p id="game-over-ratings">–ò–∑–º–µ–Ω–µ–Ω–∏–µ —Ä–µ–π—Ç–∏–Ω–≥–∞...</p>
            <h3>–ò—Å—Ç–æ—Ä–∏—è —Ä–∞—É–Ω–¥–æ–≤</h3>
            <table id="game-over-table"><thead><tr><th>–†–∞—É–Ω–¥</th><th>–ö–ª—É–±</th><th>–ò—Ç–æ–≥</th></tr></thead><tbody></tbody></table>
            <div id="game-over-buttons">
                 <button id="game-over-back-btn">–í –ª–æ–±–±–∏</button>
                 <button id="rematch-btn" style="display: none;">–†–µ–≤–∞–Ω—à</button>
            </div>
        </div>
    </div>

    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const socket = io({
                 reconnectionAttempts: 5, 
                 reconnectionDelay: 1000 
            });
            const tg = window.Telegram.WebApp;
            try {
                 tg.ready();
                 tg.expand();
            } catch (e) {
                 console.warn("Telegram WebApp script not loaded or failed:", e);
            }

            let localState = { nickname: null, telegramId: null, currentRoomId: null, myPlayerIndex: null, maxClubsInLeague: 16, isTraining: false, isSpectating: false, lastEndedGameId: null, isFinalPause: false }; 
            let gameTimerInterval = null;
            let summaryTimerInterval = null;

            const screens = { loading: document.getElementById('loading-screen'), nickname: document.getElementById('nickname-screen'), lobby: document.getElementById('lobby-screen'), settings: document.getElementById('settings-screen'), game: document.getElementById('game-screen'), summary: document.getElementById('summary-screen'), leaderboard: document.getElementById('leaderboard-screen'), gameOver: document.getElementById('game-over-screen') };
            const settingsTitle = document.getElementById('settings-title');
            const confirmCreateBtn = document.getElementById('confirm-create-game-btn');
            const confirmTrainingBtn = document.getElementById('confirm-training-btn');
            const tabButtons = document.querySelectorAll('.tab-btn');
            const tabContents = document.querySelectorAll('.tab-content');
            const randomClubsSlider = document.getElementById('random-clubs-slider');
            const randomClubsLabel = document.getElementById('random-clubs-label');
            const clubsSelectionList = document.getElementById('clubs-selection-list');
            const manualClubsCount = document.getElementById('manual-clubs-count');
            const settingsErrorMsg = document.getElementById('settings-error-msg');
            const maxClubsCountSpan = document.getElementById('max-clubs-count');
            const minClubsTextSpan = document.getElementById('min-clubs-text');
            const openGamesList = document.getElementById('open-games-list');
            const activeGamesList = document.getElementById('active-games-list');
            const summaryListContainer = document.getElementById('summary-list-container');
            const gameOverBackBtn = document.getElementById('game-over-back-btn');
            const summaryCountdownDisplay = document.getElementById('summary-countdown');
            const skipPauseBtn = document.getElementById('skip-pause-btn');
            const spectatorInfo = document.getElementById('spectator-info');
            const spectatorBackBtn = document.getElementById('spectator-back-btn');
            const gameControls = document.getElementById('game-controls');
            const namedPlayersContainer = document.getElementById('named-players-container');
            const namedPlayersList0 = document.getElementById('named-players-list-0');
            const namedPlayersList1 = document.getElementById('named-players-list-1');
            const lobbyStatsEl = document.getElementById('lobby-stats');
            const guessResultMsg = document.getElementById('guess-result-msg');
            const timeBankInput = document.getElementById('time-bank-input');
            const rematchBtn = document.getElementById('rematch-btn');

            summaryListContainer.addEventListener('scroll', () => { 
                 const w = summaryListContainer.parentElement; 
                 w.classList.toggle('scrolled-to-bottom', summaryListContainer.scrollHeight - summaryListContainer.scrollTop <= summaryListContainer.clientHeight + 1); 
            });
            
            gameOverBackBtn.addEventListener('click', () => {
                 if (localState.lastEndedGameId) {
                     console.log(`[Rematch] Leaving game over screen for ${localState.lastEndedGameId}`);
                     socket.emit('leave_game_over_screen', { old_room_id: localState.lastEndedGameId });
                     localState.lastEndedGameId = null; 
                 }
                 showScreen('lobby'); 
            });

            spectatorBackBtn.addEventListener('click', () => { 
                 if (localState.currentRoomId) {
                      socket.emit('leave_as_spectator', { roomId: localState.currentRoomId }); 
                 }
                 localState.isSpectating = false; 
                 localState.currentRoomId = null; 
                 showScreen('lobby'); 
            });

            function showScreen(screenName) {
                if (gameTimerInterval) { clearInterval(gameTimerInterval); gameTimerInterval = null; }
                if (screenName !== 'summary' && summaryTimerInterval) { 
                    clearInterval(summaryTimerInterval); 
                    summaryTimerInterval = null; 
                    console.log("[Timer] Cleared summary timer due to screen change.");
                }

                const screenKey = Object.keys(screens).find(key => screens[key] === document.getElementById(`${screenName}-screen`)) || screenName;
                if (!screens[screenKey]) {
                     console.error("Screen not found:", screenName);
                     return;
                }
                Object.values(screens).forEach(screen => screen.classList.remove('active'));
                screens[screenKey].classList.add('active');

                 if (screenName !== 'gameOver' && screenName !== 'game' && screenName !== 'summary' && localState.lastEndedGameId) {
                      console.log(`[Rematch] Leaving Game Over screen implicitly for ${localState.lastEndedGameId}, going to ${screenName}`);
                      socket.emit('leave_game_over_screen', { old_room_id: localState.lastEndedGameId });
                      localState.lastEndedGameId = null; 
                 }
            }

            socket.on('connect', () => {
                 console.log('Connected. Requesting auth...');
                 screens.loading.querySelector('.loader').style.display = 'block'; 
                 screens.loading.querySelector('p').textContent = '–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...';
                 showScreen('loading'); 
                 if (tg && tg.initData) {
                    socket.emit('login_with_telegram', { initData: tg.initData });
                 } else {
                     console.warn("Telegram initData not found.");
                     screens.loading.querySelector('.loader').style.display = 'none';
                     screens.loading.querySelector('p').textContent = '–û—à–∏–±–∫–∞: –ó–∞–ø—É—Å—Ç–∏—Ç–µ —á–µ—Ä–µ–∑ Telegram.';
                 }
            });

            socket.on('disconnect', (reason) => {
                 console.log('Disconnected:', reason);
                 if (gameTimerInterval) clearInterval(gameTimerInterval); gameTimerInterval = null;
                 if (summaryTimerInterval) clearInterval(summaryTimerInterval); summaryTimerInterval = null;
                 localState.lastEndedGameId = null; 
                 screens.loading.querySelector('.loader').style.display = 'none';
                 screens.loading.querySelector('p').textContent = `–û—Ç–∫–ª—é—á–µ–Ω–æ: ${reason}. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å.`;
                 showScreen('loading'); 
            });

            socket.on('connect_error', (err) => {
                console.error('Connection error:', err.message);
                screens.loading.querySelector('.loader').style.display = 'none';
                screens.loading.querySelector('p').textContent = `–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç.`;
                showScreen('loading');
            });

            socket.on('request_nickname', (data) => { localState.telegramId = data.telegram_id; showScreen('nickname'); });
            
            socket.on('auth_status', (data) => {
                if (data.success) {
                    localState.nickname = data.nickname;
                    document.getElementById('welcome-message').textContent = `–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å, ${localState.nickname}!`;
                    socket.emit('get_lobby_data'); 
                    showScreen('lobby');
                } else { 
                    if (screens.loading.classList.contains('active')) {
                        screens.loading.querySelector('.loader').style.display = 'none';
                        screens.loading.querySelector('p').textContent = `–û—à–∏–±–∫–∞: ${data.message || '–û—à–∏–±–∫–∞ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏.'}`;
                        if (data.message && data.message.includes('—É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞')) {
                             // –ù–µ –æ—Ç–∫–ª—é—á–∞–µ–º —Å–æ–∫–µ—Ç
                        }
                    } else if (screens.nickname.classList.contains('active')) {
                        document.getElementById('nickname-error').textContent = data.message || '–û—à–∏–±–∫–∞.'; 
                    } else {
                         alert(`–û—à–∏–±–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏: ${data.message}`);
                         screens.loading.querySelector('.loader').style.display = 'none';
                         screens.loading.querySelector('p').textContent = `–û—à–∏–±–∫–∞: ${data.message}`;
                         showScreen('loading');
                    }
                }
            });

            socket.on('round_summary', (data) => {
                if (gameTimerInterval) { clearInterval(gameTimerInterval); gameTimerInterval = null; }
                if (summaryTimerInterval && !screens.summary.classList.contains('active')) {
                    clearInterval(summaryTimerInterval); summaryTimerInterval = null;
                }

                localState.isFinalPause = data.isGameOverAfterPause === true; // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ñ–ª–∞–≥

                summaryListContainer.parentElement.classList.remove('scrolled-to-bottom');
                summaryListContainer.scrollTop = 0;

                document.getElementById('summary-club-name').textContent = data.clubName;
                
                let displayScoreIndex0 = localState.isSpectating ? 0 : localState.myPlayerIndex;
                let displayScoreIndex1 = localState.isSpectating ? 1 : (1 - localState.myPlayerIndex);
                let score0 = data.scores.hasOwnProperty(displayScoreIndex0) ? data.scores[displayScoreIndex0] : 0;
                let score1 = data.scores.hasOwnProperty(displayScoreIndex1) ? data.scores[displayScoreIndex1] : 0;
                document.getElementById('summary-score').textContent = `${score0} - ${score1}`;

                const summaryList = document.getElementById('summary-player-list');
                summaryList.innerHTML = '';
                (data.fullPlayerList || []).forEach(fullName => {
                    const li = document.createElement('li');
                    const namedPlayer = (data.namedPlayers || []).find(p => p.full_name === fullName);
                    if (namedPlayer && data.players && data.players[namedPlayer.by]) { 
                         const author = data.players[namedPlayer.by].nickname; 
                         li.innerHTML = `‚úÖ ${fullName} (<em>${author}</em>)`; li.style.color = 'var(--correct-color)'; 
                    } else { 
                         li.innerHTML = `‚ùå ${fullName}`; li.style.color = 'var(--text-color)'; 
                    }
                    summaryList.appendChild(li);
                });

                const buttonText = localState.isFinalPause ? '–ö –∏—Ç–æ–≥–∞–º –∏–≥—Ä—ã' : '–°–ª–µ–¥—É—é—â–∏–π —Ä–∞—É–Ω–¥';
                skipPauseBtn.textContent = buttonText;
                
                if (localState.isSpectating) {
                    skipPauseBtn.style.display = 'none';
                } else {
                    skipPauseBtn.style.display = 'block';
                    // –°–±—Ä–∞—Å—ã–≤–∞–µ–º disabled —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —Ç–µ–∫—Å—Ç –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç '–ì–æ–ª–æ—Å –ø—Ä–∏–Ω—è—Ç'
                    if (!skipPauseBtn.textContent.includes('–ì–æ–ª–æ—Å –ø—Ä–∏–Ω—è—Ç')) {
                       skipPauseBtn.disabled = false; 
                    }
                }

                showScreen('summary');

                const endTime = data.pauseEndTime * 1000; 
                function updateCountdown() {
                    const now = Date.now();
                    const timeLeft = Math.max(0, Math.ceil((endTime - now) / 1000));
                    if (screens.summary.classList.contains('active') && summaryTimerInterval) { 
                        summaryCountdownDisplay.textContent = timeLeft; 
                    }
                    if (timeLeft <= 0) { 
                        if(summaryTimerInterval) clearInterval(summaryTimerInterval); 
                        summaryTimerInterval = null; 
                    }
                }
                
                if (!summaryTimerInterval) {
                    updateCountdown(); 
                    summaryTimerInterval = setInterval(updateCountdown, 1000);
                } else {
                     updateCountdown(); 
                }
            });

            // –ù–µ –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–∞–π–º–µ—Ä –ø–æ –∫–ª–∏–∫—É
            skipPauseBtn.addEventListener('click', () => {
                console.log("[Skip] Skip button clicked.");
                socket.emit('request_skip_pause', { roomId: localState.currentRoomId });
            });

            socket.on('skip_vote_accepted', () => {
                console.log("[Skip] Skip vote accepted by server.");
                skipPauseBtn.disabled = true;
                 const buttonBaseText = localState.isFinalPause ? '–ö –∏—Ç–æ–≥–∞–º –∏–≥—Ä—ã' : '–°–ª–µ–¥—É—é—â–∏–π —Ä–∞—É–Ω–¥';
                 skipPauseBtn.textContent = `–ì–æ–ª–æ—Å –ø—Ä–∏–Ω—è—Ç... (${buttonBaseText})`; 
            });

            // --- –ò–ó–ú–ï–ù–ï–ù–ò–ï: –ò—Å–ø–æ–ª—å–∑—É–µ–º isFinalPause –¥–ª—è —Ç–µ–∫—Å—Ç–∞ update ---
            socket.on('skip_vote_update', (data) => {
                 console.log("[Skip] Skip vote update:", data.count);
                 // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –±–∞–∑–æ–≤—ã–π —Ç–µ–∫—Å—Ç –∫–Ω–æ–ø–∫–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω–æ–≥–æ —Ñ–ª–∞–≥–∞
                 const buttonBaseText = localState.isFinalPause ? '–ö –∏—Ç–æ–≥–∞–º –∏–≥—Ä—ã' : '–°–ª–µ–¥—É—é—â–∏–π —Ä–∞—É–Ω–¥';
                 
                 if (!localState.isSpectating) { 
                     // –û–±–Ω–æ–≤–ª—è–µ–º —Ç–µ–∫—Å—Ç, —á—Ç–æ–±—ã –ø–æ–∫–∞–∑–∞—Ç—å —Å—á–µ—Ç—á–∏–∫ (1/2 –∏–ª–∏ 2/2)
                     skipPauseBtn.textContent = `${buttonBaseText} (${data.count}/2)`;
                     skipPauseBtn.disabled = true; // –î–µ—Ä–∂–∏–º –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–Ω–æ–π
                 }
            });
            // --- –ö–û–ù–ï–¶ –ò–ó–ú–ï–ù–ï–ù–ò–Ø ---

            socket.on('round_started', (state) => {
                 console.log("[Game] Round started event received.");
                 if (summaryTimerInterval) { 
                      clearInterval(summaryTimerInterval); 
                      summaryTimerInterval = null; 
                      console.log("[Timer] Cleared summary timer on round start.");
                 } 
                 localState.lastEndedGameId = null; 
                 localState.currentRoomId = state.roomId; 
                 showScreen('game');
                 updateGameUI(state);
            });

            function updateGameUI(state) {
                // --- –ò–ó–ú–ï–ù–ï–ù–ò–ï: –õ–æ–≥–∏–∫–∞ –∏–Ω–ø—É—Ç–∞ –∏ –∫–Ω–æ–ø–æ–∫ ---
                if (gameTimerInterval) { clearInterval(gameTimerInterval); gameTimerInterval = null; }
                localState.currentRoomId = state.roomId;
                localState.myPlayerIndex = -1; 
                if(state.players) {
                    for (const i in state.players) { 
                        if (state.players[i].nickname === localState.nickname) { 
                            localState.myPlayerIndex = parseInt(i); 
                            break; 
                        } 
                    }
                }
                localState.isSpectating = (localState.myPlayerIndex === -1);

                gameControls.style.display = localState.isSpectating ? 'none' : 'block';
                spectatorBackBtn.style.display = localState.isSpectating ? 'block' : 'none';

                const myDisplayIndex = 0, opponentDisplayIndex = 1;
                const displayPlayer0ActualIndex = localState.isSpectating ? 0 : localState.myPlayerIndex;
                const displayPlayer1ActualIndex = localState.isSpectating ? 1 : (1 - localState.myPlayerIndex);
                
                const playerElements = [document.getElementById(`player-${myDisplayIndex}-info`), document.getElementById(`player-${opponentDisplayIndex}-info`)];

                document.getElementById('round-info').textContent = `–†–∞—É–Ω–¥ ${state.round || '?'}/${state.totalRounds || '?'}`;
                document.getElementById('club-name-display').textContent = state.clubName || '–ó–∞–≥—Ä—É–∑–∫–∞...';
                spectatorInfo.textContent = state.spectatorInfoText || '';

                const updatePlayerPanel = (panelIndex, actualIndex) => {
                     const playerEl = playerElements[panelIndex];
                     const playerInfo = state.players ? state.players[actualIndex] : null;
                     const playerScore = state.scores ? (state.scores.hasOwnProperty(actualIndex) ? state.scores[actualIndex] : 0) : 0;
                     const playerTime = state.timeBanks ? (state.timeBanks.hasOwnProperty(actualIndex) ? state.timeBanks[actualIndex] : 0) : 0;

                     if (playerInfo) {
                         playerEl.style.display = 'block';
                         const isMe = localState.myPlayerIndex === actualIndex;
                         playerEl.querySelector('.nickname').textContent = playerInfo.nickname + (isMe ? ' (–í—ã)' : '');
                         playerEl.querySelector('.score').textContent = playerScore;
                         const timeEl = playerEl.querySelector('.time-bank');
                         if (playerTime < 20) { 
                              timeEl.style.color = 'var(--incorrect-color)'; 
                              timeEl.textContent = `${playerTime.toFixed(2)}—Å`; 
                         } else { 
                              timeEl.style.color = 'var(--text-color)'; 
                              timeEl.textContent = `${playerTime.toFixed(1)}—Å`; 
                         }
                         playerEl.classList.toggle('active', actualIndex === state.currentPlayerIndex);
                     } else {
                         playerEl.style.display = 'none'; 
                     }
                };

                updatePlayerPanel(myDisplayIndex, displayPlayer0ActualIndex);
                updatePlayerPanel(opponentDisplayIndex, displayPlayer1ActualIndex);

                const currentActualIndex = state.currentPlayerIndex;
                const activeDisplayIndex = (currentActualIndex === displayPlayer0ActualIndex) ? myDisplayIndex : opponentDisplayIndex;
                const activeTimeEl = playerElements[activeDisplayIndex]?.querySelector('.time-bank');
                let activeTimeLeft = state.timeBanks ? (state.timeBanks.hasOwnProperty(currentActualIndex) ? state.timeBanks[currentActualIndex] : 0) : 0;
                
                if (activeTimeEl && activeTimeLeft > 0) {
                    gameTimerInterval = setInterval(() => {
                        activeTimeLeft -= 0.1; 
                        if (activeTimeLeft < 0) activeTimeLeft = 0;
                        
                        const currentActiveTimeEl = playerElements[activeDisplayIndex]?.querySelector('.time-bank');
                        if (!currentActiveTimeEl) {
                             if (gameTimerInterval) clearInterval(gameTimerInterval); gameTimerInterval = null; return;
                        }

                        if (activeTimeLeft < 20) { 
                             currentActiveTimeEl.style.color = 'var(--incorrect-color)'; 
                             currentActiveTimeEl.textContent = `${activeTimeLeft.toFixed(2)}—Å`; 
                        } else { 
                             currentActiveTimeEl.style.color = 'var(--text-color)'; 
                             currentActiveTimeEl.textContent = `${activeTimeLeft.toFixed(1)}—Å`; 
                        }
                        if (activeTimeLeft <= 0) { 
                             if (gameTimerInterval) clearInterval(gameTimerInterval); gameTimerInterval = null;
                        }
                    }, 100);
                }

                namedPlayersList0.innerHTML = ''; 
                namedPlayersList1.innerHTML = '';
                
                (state.namedPlayers || []).forEach(p => {
                    const li = document.createElement('li');
                    li.textContent = p.full_name; 
                    if (p.by === displayPlayer0ActualIndex) namedPlayersList0.prepend(li); 
                    else if (p.by === displayPlayer1ActualIndex) namedPlayersList1.prepend(li); 
                });

                namedPlayersContainer.style.display = 'flex'; 
                const p0_has_names = namedPlayersList0.children.length > 0;
                const p1_has_names = namedPlayersList1.children.length > 0;

                if (state.mode === 'solo') {
                    namedPlayersList0.style.backgroundColor = 'var(--primary-color)';
                    namedPlayersList1.style.display = 'none'; 
                    namedPlayersList0.style.display = 'block'; 
                     if (!p0_has_names) { 
                          namedPlayersContainer.style.display = 'none';
                     }
                } else { 
                    namedPlayersList1.style.display = 'block'; 
                    namedPlayersList0.style.display = 'block';
                    
                    const emptyColor = 'var(--empty-column-color)';
                    const defaultColor = 'var(--primary-color)';

                    namedPlayersList0.style.backgroundColor = p0_has_names ? defaultColor : emptyColor;
                    namedPlayersList1.style.backgroundColor = p1_has_names ? defaultColor : emptyColor;
                     namedPlayersContainer.style.display = 'flex'; 
                }

                const guessInput = document.getElementById('guess-input');
                const submitGuessBtn = document.getElementById('submit-guess-btn');
                const surrenderBtn = document.getElementById('surrender-btn');
                const isMyActualTurn = state.currentPlayerIndex === localState.myPlayerIndex;

                if (!localState.isSpectating) {
                     guessInput.disabled = false; // –í—Å–µ–≥–¥–∞ –≤–∫–ª—é—á–µ–Ω –¥–ª—è –≤–≤–æ–¥–∞
                     guessInput.placeholder = isMyActualTurn ? "–í–≤–µ–¥–∏—Ç–µ —Ñ–∞–º–∏–ª–∏—é –∏–≥—Ä–æ–∫–∞" : "–°–µ–π—á–∞—Å —Ö–æ–¥ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞...";
                     guessInput.classList.toggle('opponent-turn', !isMyActualTurn); 

                     submitGuessBtn.disabled = !isMyActualTurn; // –ö–Ω–æ–ø–∫–∏ –±–ª–æ–∫–∏—Ä—É–µ–º
                     surrenderBtn.disabled = !isMyActualTurn;
                     
                     if (isMyActualTurn) { 
                          guessInput.focus(); 
                     }
                } else { // –ó—Ä–∏—Ç–µ–ª—å
                     guessInput.disabled = true;
                     guessInput.placeholder = "–†–µ–∂–∏–º –∑—Ä–∏—Ç–µ–ª—è";
                     guessInput.classList.remove('opponent-turn'); 
                     submitGuessBtn.disabled = true;
                     surrenderBtn.disabled = true;
                }
                // --- –ö–û–ù–ï–¶ –ò–ó–ú–ï–ù–ï–ù–ò–Ø ---

                if (guessResultMsg) {
                    guessResultMsg.textContent = '';
                }
            }

            function getRoundOutcomeText(round, p0_nick, p1_nick) {
                // (–ë–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)
                const reason = round.result_type;
                const winnerIndex = round.winner_index; 

                if (reason === 'completed' || winnerIndex === 'draw') {
                    return '–ù–∏—á—å—è';
                } else if (winnerIndex === 0 || winnerIndex === 1) { 
                    const winnerNick = (winnerIndex === 0) ? p0_nick : p1_nick;
                    let reasonText = '';
                    if (reason === 'surrender') { reasonText = '(—Å–¥–∞—á–∞)'; }
                    else if (reason === 'timeout') { reasonText = '(–≤—Ä–µ–º—è)'; }

                    if (!p1_nick) { 
                         if (reason === 'surrender') return '–°–¥–∞–ª—Å—è';
                         if (reason === 'timeout') return '–í—Ä–µ–º—è –≤—ã—à–ª–æ';
                         return '–ó–∞–≤–µ—Ä—à–µ–Ω–æ'; 
                    } else { 
                         return `–ü–æ–±. ${winnerNick} ${reasonText}`;
                    }
                }
                console.warn("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∏—Å—Ö–æ–¥ —Ä–∞—É–Ω–¥–∞:", round);
                return '–Ω/–¥';
            }

            socket.on('game_over', (data) => {
                 // (–ë–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)
                console.log("[Game] Game Over event received:", data);
                if (gameTimerInterval) clearInterval(gameTimerInterval); gameTimerInterval = null;
                if (summaryTimerInterval) clearInterval(summaryTimerInterval); summaryTimerInterval = null; 
                
                const amIPlayer = localState.nickname && ((data.players[0] && data.players[0].nickname === localState.nickname) || (data.players[1] && data.players[1].nickname === localState.nickname));
                
                if (localState.isSpectating || !amIPlayer) {
                     console.log("[Game Over] Was spectator or not a player, going to lobby.");
                     localState.isSpectating = false; 
                     localState.currentRoomId = null;
                     localState.lastEndedGameId = null;
                     showScreen('lobby');
                     return; 
                }

                localState.lastEndedGameId = data.old_room_id; 
                
                const p0_nick = data.players[0].nickname;
                const p1_nick = data.players[1] ? data.players[1].nickname : null;
                const myOriginalIndex = (localState.nickname === p0_nick) ? 0 : (p1_nick === localState.nickname ? 1 : -1);
                
                if (myOriginalIndex === -1 && data.mode === 'pvp') {
                     console.warn("[Game Over] Couldn't find myself in players data, going to lobby.");
                     localState.lastEndedGameId = null;
                     showScreen('lobby');
                     return;
                }

                const opponentOriginalIndex = (data.mode !== 'solo' && myOriginalIndex !== -1) ? 1 - myOriginalIndex : -1;

                const myFinalScore = data.final_scores.hasOwnProperty(myOriginalIndex) ? data.final_scores[myOriginalIndex] : 0;
                const opponentFinalScore = (opponentOriginalIndex !== -1 && data.final_scores.hasOwnProperty(opponentOriginalIndex)) ? data.final_scores[opponentOriginalIndex] : 0;
                document.getElementById('game-over-score').textContent = `–°—á–µ—Ç ${myFinalScore} - ${opponentFinalScore}`;
                
                const endReasonText = { 'normal': '–ò–≥—Ä–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞ –ø–æ –∫–æ–ª-–≤—É —Ä–∞—É–Ω–¥–æ–≤.', 'unreachable_score': '–°—á–µ—Ç —Å—Ç–∞–ª –Ω–µ–¥–æ—Å—è–≥–∞–µ–º—ã–º.', 'internal_error': '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞.' };
                document.getElementById('game-over-reason').textContent = endReasonText[data.end_reason] || '–ò–≥—Ä–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞.';

                let ratingText = '';
                rematchBtn.style.display = 'none';

                if (data.mode === 'solo') { 
                    ratingText = '–†–µ–π—Ç–∏–Ω–≥ –≤ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–µ –Ω–µ –º–µ–Ω—è–µ—Ç—Å—è.'; 
                }
                else if (data.rating_changes && opponentOriginalIndex !== -1 && myOriginalIndex !== -1) {
                    const myChanges = data.rating_changes[myOriginalIndex.toString()];
                    const opponentChanges = data.rating_changes[opponentOriginalIndex.toString()];
                    if (myChanges && opponentChanges) {
                         const myDiff = myChanges.new - myChanges.old; 
                         const oppDiff = opponentChanges.new - opponentChanges.old;
                        ratingText = `<b>${myChanges.nickname} (–í—ã):</b> ${myChanges.new} (${myDiff >= 0 ? '+' : ''}${myDiff})<br><b>${opponentChanges.nickname}:</b> ${opponentChanges.new} (${oppDiff >= 0 ? '+' : ''}${oppDiff})`;
                        rematchBtn.style.display = 'block';
                        rematchBtn.textContent = '–†–µ–≤–∞–Ω—à';
                        rematchBtn.disabled = localState.isSpectating; 
                    } else { ratingText = '–û—à–∏–±–∫–∞ —Ä–∞—Å—á–µ—Ç–∞ —Ä–µ–π—Ç–∏–Ω–≥–∞.'; }
                } else { 
                    ratingText = '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –æ —Ä–µ–π—Ç–∏–Ω–≥–µ.'; 
                }
                document.getElementById('game-over-ratings').innerHTML = ratingText;

                const historyTable = document.querySelector('#game-over-table tbody'); historyTable.innerHTML = '';
                if (data.history && data.history.length > 0) {
                    data.history.forEach((round, i) => { const tr = document.createElement('tr'); const outcome = getRoundOutcomeText(round, p0_nick, p1_nick); tr.innerHTML = `<td>${i + 1}</td><td>${round.club_name}</td><td>${outcome}</td>`; historyTable.appendChild(tr); });
                } else { historyTable.innerHTML = `<tr><td colspan="3">–ò—Å—Ç–æ—Ä–∏—è –ø—É—Å—Ç–∞.</td></tr>`; }

                showScreen('gameOver');
            });

            socket.on('guess_result', (data) => {
                 // (–ë–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)
                let msg = '';
                let color = 'var(--text-color)';

                if (data.result === 'correct') {
                    msg = '‚úÖ –í–µ—Ä–Ω–æ!';
                    color = 'var(--correct-color)';
                } else if (data.result === 'correct_typo') {
                    msg = `‚úÖ –í–µ—Ä–Ω–æ! (${data.corrected_name})`; 
                    color = 'var(--correct-color)';
                } else if (data.result === 'already_named') {
                    msg = 'üü° –£–∂–µ –Ω–∞–∑–≤–∞–Ω';
                    color = 'var(--accent-hover-color)'; 
                } else if (data.result === 'not_found') {
                    msg = '‚ùå –ù–µ–≤–µ—Ä–Ω–æ';
                    color = 'var(--incorrect-color)';
                }
                
                if (guessResultMsg) {
                    guessResultMsg.textContent = msg;
                    guessResultMsg.style.color = color;
                }

                if (data.result === 'already_named' || data.result === 'not_found') {
                    setTimeout(() => {
                        if (guessResultMsg && guessResultMsg.textContent === msg) {
                            guessResultMsg.textContent = '';
                        }
                    }, 2000);
                }
            });

            socket.on('spectator_update', (data) => { spectatorInfo.textContent = data.text || ''; });

            const nicknameInput = document.getElementById('nickname-input');
            const submitNicknameBtn = document.getElementById('submit-nickname-btn');
            submitNicknameBtn.addEventListener('click', () => { 
                 const nickValue = nicknameInput.value.trim();
                 if (nickValue) { 
                      socket.emit('set_initial_username', { nickname: nickValue, telegram_id: localState.telegramId }); 
                 } else {
                      document.getElementById('nickname-error').textContent = '–ù–∏–∫–Ω–µ–π–º –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.';
                 }
            });

            document.getElementById('create-game-btn').addEventListener('click', () => openSettings(false));
            document.getElementById('start-training-btn').addEventListener('click', () => openSettings(true));
            document.getElementById('back-to-lobby-btn').addEventListener('click', () => showScreen('lobby'));
            document.getElementById('surrender-btn').addEventListener('click', () => { 
                if (confirm("–°–¥–∞—Ç—å—Å—è –≤ —ç—Ç–æ–º —Ä–∞—É–Ω–¥–µ?")) {
                    socket.emit('surrender_round', { roomId: localState.currentRoomId }); 
                }
            });

            function openSettings(isTraining) {
                 if (localState.lastEndedGameId) {
                     console.log(`[Rematch] Leaving Game Over implicitly for ${localState.lastEndedGameId} on opening settings.`);
                     socket.emit('leave_game_over_screen', { old_room_id: localState.lastEndedGameId });
                     localState.lastEndedGameId = null;
                 }

                localState.isTraining = isTraining; 
                settingsTitle.textContent = isTraining ? '–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏' : '–ù–∞—Å—Ç—Ä–æ–π–∫–∏ PvP'; 
                confirmTrainingBtn.style.display = isTraining ? 'block' : 'none'; 
                confirmCreateBtn.style.display = isTraining ? 'none' : 'block';
                
                tabButtons.forEach(btn => btn.classList.remove('active')); 
                tabContents.forEach(content => content.classList.remove('active')); 
                document.querySelector('.tab-btn[data-tab="random"]').classList.add('active'); 
                document.getElementById('tab-random').classList.add('active');
                
                const minClubs = isTraining ? 1 : 3; 
                minClubsTextSpan.textContent = minClubs; 
                randomClubsSlider.min = minClubs;
                
                const defaultValue = Math.max(minClubs, Math.min(10, localState.maxClubsInLeague || 10)); 
                randomClubsSlider.value = defaultValue; 
                randomClubsLabel.textContent = `–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–ª—É–±–æ–≤: ${defaultValue}`;
                
                manualClubsCount.textContent = '–í—ã–±—Ä–∞–Ω–æ: 0';
                 if (clubsSelectionList) { 
                     Array.from(clubsSelectionList.querySelectorAll('input:checked')).forEach(cb => cb.checked = false);
                 }

                socket.emit('get_league_clubs', { league: document.getElementById('league-select').value }); 
                validateSettings(); 
                showScreen('settings');
            }

            tabButtons.forEach(button => { button.addEventListener('click', () => { tabButtons.forEach(btn => btn.classList.remove('active')); button.classList.add('active'); const tabId = button.getAttribute('data-tab'); tabContents.forEach(content => content.classList.toggle('active', content.id === `tab-${tabId}`)); validateSettings(); }); });

            socket.on('league_clubs_data', (data) => {
                localState.maxClubsInLeague = data.clubs ? data.clubs.length : 0; 
                randomClubsSlider.max = localState.maxClubsInLeague;
                maxClubsCountSpan.textContent = localState.maxClubsInLeague; 
                
                const currentSliderValue = parseInt(randomClubsSlider.value, 10);
                if (currentSliderValue > localState.maxClubsInLeague) {
                    randomClubsSlider.value = localState.maxClubsInLeague;
                }
                 const minClubs = localState.isTraining ? 1 : 3;
                 randomClubsSlider.min = minClubs;
                 if (currentSliderValue < minClubs) {
                     randomClubsSlider.value = minClubs;
                 }
                randomClubsLabel.textContent = `–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–ª—É–±–æ–≤: ${randomClubsSlider.value}`;

                clubsSelectionList.innerHTML = '';
                (data.clubs || []).forEach(club => { 
                     clubsSelectionList.innerHTML += `<label class="club-item"><input type="checkbox" value="${club}"><span style="margin-left: 8px;">${club}</span></label>`; 
                });
                validateSettings(); 
            });

            randomClubsSlider.addEventListener('input', () => { randomClubsLabel.textContent = `–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–ª—É–±–æ–≤: ${randomClubsSlider.value}`; validateSettings(); });
            clubsSelectionList.addEventListener('change', (e) => { if (e.target && e.target.type === 'checkbox') validateSettings(); }); 
            timeBankInput.addEventListener('input', validateSettings);

            function validateSettings() {
                // (–ë–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)
                const timeBankValue = parseFloat(timeBankInput.value);
                const minTime = parseInt(timeBankInput.min, 10) || 30; 
                const maxTime = parseInt(timeBankInput.max, 10) || 300; 

                const minClubs = localState.isTraining ? 1 : 3; 
                const activeTab = document.querySelector('.tab-btn.active')?.getAttribute('data-tab'); 
                
                let isValid = false; 
                let error = "";

                if (isNaN(timeBankValue) || timeBankValue < minTime || timeBankValue > maxTime) {
                    error = `–í—Ä–µ–º—è: ${minTime}-${maxTime} —Å–µ–∫—É–Ω–¥`;
                    isValid = false; 
                } 
                else { 
                    if (activeTab === 'random') {
                        const count = parseInt(randomClubsSlider.value, 10);
                        if (count < minClubs) {
                            error = `–ú–∏–Ω–∏–º—É–º ${minClubs} ${minClubs === 1 ? '–∫–ª—É–±' : '–∫–ª—É–±–∞ (—Å–ª—É—á.)'}.`;
                        } else {
                            isValid = true; 
                        }
                    } else if (activeTab === 'manual') {
                        const checkedCount = document.querySelectorAll('#clubs-selection-list input:checked').length;
                        manualClubsCount.textContent = `–í—ã–±—Ä–∞–Ω–æ: ${checkedCount}`;
                        if (checkedCount < minClubs) {
                            error = `–ú–∏–Ω–∏–º—É–º ${minClubs} ${minClubs === 1 ? '–∫–ª—É–±' : '–∫–ª—É–±–∞'} (–≤—ã–±—Ä).`;
                        } else {
                            isValid = true; 
                        }
                    } else {
                         error = "–í—ã–±–µ—Ä–∏—Ç–µ —Ä–µ–∂–∏–º –≤—ã–±–æ—Ä–∞ –∫–ª—É–±–æ–≤.";
                    }
                }
                
                settingsErrorMsg.textContent = error;
                confirmCreateBtn.disabled = !isValid;
                confirmTrainingBtn.disabled = !isValid;
            }

            function handleCreateGame(isTraining) {
                // (–ë–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)
                 validateSettings();
                 if(confirmCreateBtn.disabled && !isTraining) return;
                 if(confirmTrainingBtn.disabled && isTraining) return;

                const activeTab = document.querySelector('.tab-btn.active').getAttribute('data-tab');
                let settings = { 
                    league: document.getElementById('league-select').value, 
                    time_bank: parseFloat(timeBankInput.value), 
                    num_rounds: 0, 
                    selected_clubs: [] 
                };
                if (activeTab === 'random') settings.num_rounds = parseInt(randomClubsSlider.value, 10); 
                else if (activeTab === 'manual') settings.selected_clubs = Array.from(document.querySelectorAll('#clubs-selection-list input:checked')).map(cb => cb.value);
                
                if (isTraining) {
                    socket.emit('start_game', { mode: 'solo', nickname: localState.nickname, settings: settings }); 
                } else { 
                    socket.emit('create_game', { nickname: localState.nickname, settings: settings }); 
                    showScreen('lobby'); 
                }
            }
            confirmCreateBtn.addEventListener('click', () => handleCreateGame(false));
            confirmTrainingBtn.addEventListener('click', () => handleCreateGame(true));
            
            socket.on('create_game_fail', (data) => {
                alert(`–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –∏–≥—Ä—É: ${data.message}`);
                 showScreen('lobby');
            });
            socket.on('start_game_fail', (data) => {
                alert(`–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞—á–∞—Ç—å —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫—É: ${data.message}`);
                showScreen('lobby'); 
            });

            // --- –ò–ó–ú–ï–ù–ï–ù–ò–ï: –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å–≤–æ–µ–π –∏–≥—Ä—ã –≤ –ª–æ–±–±–∏ ---
            socket.on('update_lobby', (data) => {
                const openGames = data.open_games || [];
                const activeGames = data.active_games || [];
                
                let myOpenGameHtml = ''; 
                let otherOpenGamesHtml = ''; 

                openGames.forEach(game => {
                    let clubsText = ''; const settings = game.settings || {}; 
                    const selClubs = settings.selected_clubs;
                    const numRounds = settings.num_rounds;
                    const timeBank = settings.time_bank || '?';

                    if (selClubs && selClubs.length > 0) clubsText = `–ö–ª—É–±—ã: ${selClubs.length} —à—Ç.`; 
                    else if (numRounds && numRounds > 0) clubsText = `–°–ª—É—á–∞–π–Ω—ã–µ –∫–ª—É–±—ã: ${numRounds} —à—Ç.`; 
                    else clubsText = '–í—Å–µ –∫–ª—É–±—ã'; 
                    
                    const cardHtml = `
                         <div class="game-card">
                              <div class="game-card-info">
                                   <p><strong>${game.creator_nickname || '?'}</strong> (${game.creator_rating || '?'})</p>
                                   <p style="font-size:12px;">–í—Ä–µ–º—è: ${timeBank} —Å–µ–∫—É–Ω–¥</p>
                                   <p style="font-size:12px;">${clubsText}</p>
                              </div>
                              ${ (game.creator_sid === socket.id) 
                                   ? `<button class="cancel-btn" data-creator-sid="${game.creator_sid}">–û—Ç–º–µ–Ω–∏—Ç—å</button>` 
                                   : `<button class="join-btn" data-creator-sid="${game.creator_sid}">–í–æ–π—Ç–∏</button>` 
                              }
                         </div>`;
                         
                    if (game.creator_sid === socket.id) {
                         myOpenGameHtml = cardHtml; // –°–æ—Ö—Ä–∞–Ω—è–µ–º HTML —Å–≤–æ–µ–π –∏–≥—Ä—ã
                    } else {
                         otherOpenGamesHtml += cardHtml; // –î–æ–±–∞–≤–ª—è–µ–º HTML –¥—Ä—É–≥–∏—Ö –∏–≥—Ä
                    }
                });
                
                // –í—Å—Ç–∞–≤–ª—è–µ–º —Å–Ω–∞—á–∞–ª–∞ —Å–≤–æ—é –∏–≥—Ä—É, –ø–æ—Ç–æ–º –æ—Å—Ç–∞–ª—å–Ω—ã–µ
                openGamesList.innerHTML = (myOpenGameHtml + otherOpenGamesHtml) || '<p>–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∏–≥—Ä.</p>';
                // --- –ö–û–ù–ï–¶ –ò–ó–ú–ï–ù–ï–ù–ò–Ø ---

                activeGamesList.innerHTML = activeGames.length === 0 ? '<p>–ù–µ—Ç —Ç–µ–∫—É—â–∏—Ö –∏–≥—Ä.</p>' : '';
                activeGames.forEach(game => {
                    activeGamesList.innerHTML += `<div class="game-card"><div class="game-card-info"><p><strong>${game.player1_nickname || '?'}</strong> vs <strong>${game.player2_nickname || '?'}</strong></p><p class="spectators">üëÄ ${game.spectator_count || 0}</p></div><button class="watch-btn" data-room-id="${game.roomId}">–°–º–æ—Ç—Ä–µ—Ç—å</button></div>`;
                });
            });
            
            document.getElementById('lobby-screen').addEventListener('click', (e) => {
                if (!e.target) return;
                if (e.target.classList.contains('join-btn')) {
                     const creatorSid = e.target.getAttribute('data-creator-sid');
                     if(creatorSid) socket.emit('join_game', { creator_sid: creatorSid, nickname: localState.nickname });
                }
                if (e.target.classList.contains('cancel-btn')) {
                     socket.emit('cancel_game'); 
                }
                if (e.target.classList.contains('watch-btn')) {
                     const roomId = e.target.getAttribute('data-room-id');
                      if(roomId) socket.emit('join_as_spectator', { roomId: roomId, nickname: localState.nickname });
                }
            });
            
            socket.on('join_game_fail', (data) => {
                 alert(`–ù–µ —É–¥–∞–ª–æ—Å—å –≤–æ–π—Ç–∏: ${data.message}`);
                 socket.emit('get_lobby_data');
            });
            
            socket.on('lobby_stats_update', (stats) => {
                 lobbyStatsEl.innerHTML = `
                    –í –ª–æ–±–±–∏: ${stats.players_in_lobby || 0} | –í PvP: ${stats.players_in_pvp || 0}<br>
                    –¢—Ä–µ–Ω–∏—Ä–æ–≤–∫–∞: ${stats.players_training || 0} | –ó—Ä–∏—Ç–µ–ª–∏: ${stats.players_spectating || 0}
                 `;
            });

            socket.on('spectate_success', (data) => { 
                 localState.isSpectating = true; 
                 localState.currentRoomId = data.roomId; 
                 console.log(`[Spectate] Successfully joined room ${data.roomId}`);
            });
            socket.on('spectate_fail', (data) => { alert(`–ù–µ —É–¥–∞–ª–æ—Å—å –≤–æ–π—Ç–∏ –∑—Ä–∏—Ç–µ–ª–µ–º: ${data.message}`); });

            // --- –ò–ó–ú–ï–ù–ï–ù–ò–ï: –î–æ–±–∞–≤–ª–µ–Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ disabled –≤ Enter listener ---
            const submitGuessBtn = document.getElementById('submit-guess-btn');
            const guessInput = document.getElementById('guess-input');
            submitGuessBtn.addEventListener('click', () => { 
                const guessValue = guessInput.value.trim();
                // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –µ—Å—Ç—å —Ç–µ–∫—Å—Ç –ò –∫–Ω–æ–ø–∫–∞ –∞–∫—Ç–∏–≤–Ω–∞
                if(guessValue && !submitGuessBtn.disabled) { 
                     socket.emit('submit_guess', { roomId: localState.currentRoomId, guess: guessValue }); 
                     guessInput.value = ''; 
                }
            });
            guessInput.addEventListener('keyup', (e) => {
                 // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ Enter –Ω–∞–∂–∞—Ç –ò –∫–Ω–æ–ø–∫–∞ "–û—Ç–≤–µ—Ç–∏—Ç—å" –∞–∫—Ç–∏–≤–Ω–∞
                 if (e.key === 'Enter' && !submitGuessBtn.disabled) { 
                      submitGuessBtn.click();
                 }
            }); 
            // --- –ö–û–ù–ï–¶ –ò–ó–ú–ï–ù–ï–ù–ò–Ø ---

            document.getElementById('show-leaderboard-btn').addEventListener('click', () => { socket.emit('get_leaderboard'); showScreen('leaderboard'); });
            document.getElementById('leaderboard-back-btn').addEventListener('click', () => showScreen('lobby'));
            socket.on('leaderboard_data', (data) => { const tbody = document.querySelector('#leaderboard-table tbody'); tbody.innerHTML = ''; (data || []).forEach((u, i) => { tbody.innerHTML += `<tr><td>${i + 1}</td><td>${u.nickname || '?'}</td><td>${u.rating || '?'}</td><td>${u.games_played || 0}</td></tr>`; }); });
                        
            socket.on('opponent_disconnected', (data) => { 
                 alert(data.message || '–°–æ–ø–µ—Ä–Ω–∏–∫ –æ—Ç–∫–ª—é—á–∏–ª—Å—è.'); 
                 if (gameTimerInterval) clearInterval(gameTimerInterval); gameTimerInterval = null; 
                 if (summaryTimerInterval) clearInterval(summaryTimerInterval); summaryTimerInterval = null; 
                 localState.isSpectating = false; 
                 localState.currentRoomId = null; 
                 localState.lastEndedGameId = null; 
                 showScreen('lobby'); 
            });

            rematchBtn.addEventListener('click', () => {
                 if (localState.lastEndedGameId && !rematchBtn.disabled) {
                     console.log(`[Rematch] Requesting rematch for ${localState.lastEndedGameId}`);
                     rematchBtn.disabled = true; 
                     rematchBtn.textContent = '–û–∂–∏–¥–∞–Ω–∏–µ...';
                     socket.emit('request_rematch', { old_room_id: localState.lastEndedGameId });
                 }
            });

            socket.on('rematch_status', (data) => {
                 console.log("[Rematch] Status update:", data);
                 if (screens.gameOver.classList.contains('active') && data.old_room_id === localState.lastEndedGameId) {
                    if (data.status === 'waiting') {
                         rematchBtn.textContent = `–†–µ–≤–∞–Ω—à (${data.count}/2)`;
                         if (rematchBtn.textContent.includes('–û–∂–∏–¥–∞–Ω–∏–µ') || localState.isSpectating) {
                              rematchBtn.disabled = true;
                         } else {
                              rematchBtn.disabled = false; 
                         }
                    } else if (data.status === 'opponent_left') {
                         rematchBtn.textContent = "–°–æ–ø–µ—Ä–Ω–∏–∫ –≤—ã—à–µ–ª";
                         rematchBtn.disabled = true;
                         localState.lastEndedGameId = null; 
                         // –û—Å—Ç–∞–µ–º—Å—è –Ω–∞ —ç–∫—Ä–∞–Ω–µ, –ø–æ–∫–∞ –Ω–µ –Ω–∞–∂–º–µ–º "–í –ª–æ–±–±–∏"
                    } else if (data.status === 'player_left') {
                         // –î–ª—è –∑—Ä–∏—Ç–µ–ª–µ–π
                          rematchBtn.textContent = "–ò–≥—Ä–æ–∫ –≤—ã—à–µ–ª";
                          rematchBtn.disabled = true;
                          localState.lastEndedGameId = null; 
                    } else if (data.status === 'error') {
                         alert(`–û—à–∏–±–∫–∞ —Ä–µ–≤–∞–Ω—à–∞: ${data.message}`);
                         rematchBtn.textContent = "–û—à–∏–±–∫–∞";
                         rematchBtn.disabled = true;
                         localState.lastEndedGameId = null;
                    }
                 } else if (data.old_room_id === localState.lastEndedGameId) {
                     console.log("[Rematch] Status received while not on Game Over screen.");
                      if (data.status === 'opponent_left' || data.status === 'player_left' || data.status === 'error') {
                           localState.lastEndedGameId = null; 
                      }
                 }
            });

            socket.on('rematch_started', (data) => {
                 console.log("[Rematch] Rematch started! New room:", data.new_room_id);
                 localState.lastEndedGameId = null; 
                 localState.currentRoomId = data.new_room_id; 
                 // –ù–µ –ø–µ—Ä–µ—Ö–æ–¥–∏–º –Ω–∞ —ç–∫—Ä–∞–Ω –∏–≥—Ä—ã, –∂–¥–µ–º 'round_started'
            });

        });
    </script>
</body>
</html>